use crate::ast::ast_node::{AstNode, AddOp, MulOp, Assignment, Condition, Expr, Stmt, Identifier, CmpOp, FunctionReturnType, Item};
use crate::symbol_table::{SymbolTable, NumType};
use crate::symbol_table;
use crate::symbol_table::decl::{StringDecl, IntDecl, FloatDecl};
use lalrpop_util::ParseError;
use std::str::FromStr;

grammar;

//////////////////////////
///////// Tokens /////////
//////////////////////////
match {
    // Keywords
    "PROGRAM" => PROGRAM,
    "BEGIN" => BEGIN,
    "END" => END,
    "FUNCTION" => FUNCTION,
    "READ" => READ,
    "WRITE" => WRITE,
    "IF" => IF,
    "ELSE" => ELSE,
    "FI" => FI,
    "FOR" => FOR,
    "ROF" => ROF,
    "RETURN" => RETURN,
    "INT" => INT,
    "VOID" => VOID,
    "STRING" => STRING,
    "FLOAT" => FLOAT,

    // Operators
    ":=",
    "+",
    "-",
    "*",
    "/",
    "=",
    "!=",
    "<",
    ">",
    "(",
    ")",
    ";",
    ",",
    "<=",
    ">=",

    // Identifiers
    r"[a-zA-Z][a-zA-Z0-9]*" => IDENTIFIER,

    // Literals
    r"[0-9]+" => INTLITERAL,
    r"[0-9]+\.[0-9]+|\.[0-9]+" => FLOATLITERAL,
    r#""[^"]*""# => STRINGLITERAL,

    // Discard comments
    r"\s*" => { },
    r"--[^\n\r]*" => { },
}

//////////////////////////
///////// Grammar ////////
//////////////////////////
pub Program: Vec<AstNode> = {
    PROGRAM IDENTIFIER BEGIN <pgm_body> end_program,
};

end_program: () = {
    END => {
        SymbolTable::end_curr_scope();
    },
};

empty: () = ();

pgm_body: Vec<AstNode> = {
    decl <func_declarations>,
};

decl: () = {
    string_decl decl,
    var_decl decl,
    empty,
};

string_decl: () = {
    STRING <id:IDENTIFIER> ":=" <val:STRINGLITERAL> ";" =>? {
        SymbolTable::add_symbol(StringDecl::new(
            id.to_owned(),
            val.to_owned()
        ), false).or_else(|decl_err| {
            SymbolTable::set_decl_error(decl_err);
            Err(ParseError::User {
                error: "Encountered declaration error!",
            })
        })
    },
};

var_decl: () = {
    <ty:var_type> <ids:id_list> ";" =>? {
        ids.iter().try_for_each(|&id| {
            match ty {
                NumType::Float => SymbolTable::add_symbol(FloatDecl::new(id.to_owned()), false),
                NumType::Int => SymbolTable::add_symbol(IntDecl::new(id.to_owned()), false),
            }.or_else(|decl_err| {
                SymbolTable::set_decl_error(decl_err);
                Err(ParseError::User {
                    error: "Encountered declaration error!",
                })
            })
        })
    },
};

var_type: NumType = {
    FLOAT => NumType::Float,
    INT => NumType::Int,
};

any_type: FunctionReturnType = {
    <var_type> => match <> {
        NumType::Float => FunctionReturnType::Float,
        NumType::Int => FunctionReturnType::Int,
    },
    VOID => FunctionReturnType::Void,
};

id_list: Vec<&'input str> = {
    <mut ids: (<IDENTIFIER> ",")*> <id: IDENTIFIER?> => match id {
        Some(id) => {
            ids.push(id);
            ids
        },
        None => ids,
    },
};

param_decl_list: () = {
    param_decl param_decl_tail,
    empty,
};

param_decl: () = {
    <ty:var_type> <id:IDENTIFIER> =>? {
        match ty {
            NumType::Float => SymbolTable::add_symbol(FloatDecl::new(id.to_owned()), true),
            NumType::Int => SymbolTable::add_symbol(IntDecl::new(id.to_owned()), true),
        }.or_else(|decl_err| {
            SymbolTable::set_decl_error(decl_err);
            Err(ParseError::User {
                error: "Encountered declaration error!",
            })
        })
    },
};

param_decl_tail: () = {
    "," param_decl param_decl_tail,
    empty,
};

// TODO: For STAGE 4 only -
//  Instead of returning a Vec<AstNode> this should
//  return a variant of AstNode itself, in the future.
//
//  We're also just combining the ast nodes from all
//  functions. It doesn't matter cause there will only
// be one function in stage 4.
func_declarations: Vec<AstNode> = {
    <func_decl: func_decl> <mut func_declarations: func_declarations> => {
        func_declarations.push(func_decl);
        func_declarations
    },
    empty => vec![],
};

func_decl: AstNode = {
    <metadata: start_func> "("param_decl_list")" BEGIN <body: func_body> end_func => {
        AstNode::Item(Item::Function {
            return_type: metadata.0,
            name: metadata.1,
            body,
        })
    },
};

start_func: (FunctionReturnType, String) = {
    FUNCTION <return_type: any_type> <id:IDENTIFIER> => {
        SymbolTable::add_function_scope(id);
        // TODO: init value for local slot map may need to change
        //  depending on how we store registers.
        symbol_table::init_stack_frame_local_slot_counter(0);
        symbol_table::init_stack_frame_param_slot_counter(0);

        (return_type, id.to_owned())
    },
};

end_func: () = {
    END => {
        SymbolTable::end_curr_scope();
        symbol_table::reset_stack_frame_local_slot_counter();
        symbol_table::reset_stack_frame_param_slot_counter();
    },
};

// TODO: For STAGE 4 only -
//  Instead of returning a Vec<Stmt> this should
//  return a variant of AstNode itself, in the future.
func_body: Vec<Stmt> = {
    decl <stmt_list>,
};

stmt_list: Vec<Stmt> = {
    <stmt: stmt> <mut stmt_list: stmt_list> => {
        stmt_list.push(stmt);
        stmt_list
     },
    empty => vec![],
};

stmt: Stmt = {
    base_stmt,
    if_stmt,
    for_stmt,
};

base_stmt: Stmt = {
    assign_stmt,
    read_stmt,
    write_stmt,
    return_stmt,
};

assign_stmt: Stmt = {
    <assign_expr> ";" => Stmt::Assign(<>),
};

assign_expr: Assignment = {
    <id: IDENTIFIER> ":=" <expr: expr> => {
        let lhs = Identifier {
            id: id.to_string(),
            sym_type: SymbolTable::symbol_type_for(id).unwrap(),
        };

        Assignment {
            lhs,
            rhs: expr,
        }
    },
};

read_stmt: Stmt = {
    READ "(" <id_list> ")" ";" => {
        let id_list: Vec<Identifier> = <>
        .iter()
        .map(|id| {
            Identifier {
                id: id.to_string(),
                sym_type: SymbolTable::symbol_type_for(id).unwrap(),
            }
        })
        .collect();

        Stmt::Read(id_list)
    },
};

write_stmt: Stmt = {
    WRITE "(" <id_list> ")" ";" => {
        let id_list: Vec<Identifier> = <>
        .iter()
        .map(|id| {
            Identifier {
                id: id.to_string(),
                sym_type: SymbolTable::symbol_type_for(id).unwrap(),
            }
        })
        .collect();

        Stmt::Write(id_list)
    },
};

return_stmt: Stmt = {
    RETURN <expr> ";" => todo!(), // TODO: Fixme!
};

expr: Expr = {
    <mut expr_prefix: expr_prefix> <factor: factor> => {
        if let Expr::Add {
            op: _,
            lhs: _,
            ref mut rhs,
        } = &mut expr_prefix {
            *rhs = Box::new(factor);
            expr_prefix
        } else {
            factor
        }
    },
};

expr_prefix: Expr = {
    <mut expr_prefix: expr_prefix> <factor: factor> <mut addop: addop> => {
        match expr_prefix {
            Expr::None => {
                if let Expr::Add {
                    op: _,
                    ref mut lhs,
                    rhs: _,
                } = &mut addop {
                    *lhs = Box::new(factor);
                }
            },
            _ => {
                if let Expr::Add {
                    op: _,
                    lhs: _,
                    ref mut rhs,
                } = &mut expr_prefix {
                    *rhs = Box::new(factor);
                }

                if let Expr::Add {
                    op: _,
                    ref mut lhs,
                    rhs: _,
                } = &mut addop {
                    *lhs = Box::new(expr_prefix);
                }
            },
        }

        addop
    },
    empty => Expr::None,
};

factor: Expr = {
    <mut factor_prefix: factor_prefix> <postfix_expr: postfix_expr> => {
        if let Expr::Mul {
            op: _,
            lhs: _,
            ref mut rhs,
        } = &mut factor_prefix {
            *rhs = Box::new(postfix_expr);
            factor_prefix
        } else {
            postfix_expr
        }
    },
};

factor_prefix: Expr = {
    <mut factor_prefix: factor_prefix> <postfix_expr: postfix_expr> <mut mulop: mulop> => {
        match factor_prefix {
            Expr::None => {
                if let Expr::Mul {
                    op: _,
                    ref mut lhs,
                    rhs: _,
                } = &mut mulop {
                    *lhs = Box::new(postfix_expr);
                }
            },
            _ => {
                if let Expr::Mul {
                    op: _,
                    lhs: _,
                    ref mut rhs,
                } = &mut factor_prefix {
                    *rhs = Box::new(postfix_expr);
                }

                if let Expr::Mul {
                    op: _,
                    ref mut lhs,
                    rhs: _,
                } = &mut mulop {
                    *lhs = Box::new(factor_prefix);
                }
            },
        }

        mulop
    },
    empty => Expr::None,
};

postfix_expr: Expr = {
    primary,
    call_expr,
};

call_expr: Expr = {
    IDENTIFIER "(" expr_list ")" => Expr::IntLiteral(42), // TODO: Fixme!
};

expr_list: () = {
    expr expr_list_tail,
    empty,
};

expr_list_tail: () = {
    "," expr expr_list_tail,
    empty,
};

primary: Expr = {
    "(" <expr> ")",
    <IDENTIFIER> => {
        // TODO: Handle failure case when symbol does not exist
        let sym_type = SymbolTable::symbol_type_for(<>).unwrap();
        Expr::Id(Identifier {
            id: <>.to_string(),
            sym_type
        })
    },
    <INTLITERAL> => {
        // TODO: Handle parsing failures
        Expr::IntLiteral(i32::from_str(<>).unwrap())
    },
    <FLOATLITERAL> => {
        // TODO: Handle parsing failures
        Expr::FloatLiteral(f64::from_str(<>).unwrap())
    },
};

addop: Expr = {
    "+" => {
        Expr::Add {
            op: AddOp::Add,
            lhs: Box::new(Expr::None),
            rhs: Box::new(Expr::None),
        }
    },
    "-" => {
       Expr::Add {
           op: AddOp::Sub,
           lhs: Box::new(Expr::None),
           rhs: Box::new(Expr::None),
       }
   },
};

mulop: Expr = {
    "*" => {
       Expr::Mul {
           op: MulOp::Mul,
           lhs: Box::new(Expr::None),
           rhs: Box::new(Expr::None),
       }
   },
    "/" => {
      Expr::Mul {
          op: MulOp::Div,
          lhs: Box::new(Expr::None),
          rhs: Box::new(Expr::None),
      }
   },
};

if_stmt: Stmt = {
    // TODO: What should `decl` return?
    start_if "(" <condition: cond> ")" decl <mut then_block: stmt_list> <mut else_block: else_part> end_if_or_else => {
        // TODO: ADD a comment for why we need to reverse.
        then_block.reverse();
        else_block.reverse();

        Stmt::If {
            condition,
            then_block,
            else_block
        }
    },
};

start_if: () = {
    IF => {
        SymbolTable::add_anonymous_scope();
    },
};

end_if_or_else: () = {
    FI => {
        SymbolTable::end_curr_scope();
    },
};

else_part: Vec<Stmt> = {
    // TODO: What should `decl` return?
    start_else decl <stmt_list: stmt_list> => stmt_list,
    empty => vec![],
};

start_else: () = {
    ELSE => {
        // End corresponding IF block, which should
        // at this point be the curr scope.
        SymbolTable::end_curr_scope();
        SymbolTable::add_anonymous_scope();
    },
};

cond: Condition = {
    <lhs: expr> <cmp_op: compop> <rhs: expr> => Condition {
        cmp_op,
        lhs,
        rhs
    },
};

compop: CmpOp = {
   "<" => CmpOp::Lt,
    ">" => CmpOp::Gt,
    "=" => CmpOp::Eq,
    "!=" => CmpOp::Ne,
    "<=" => CmpOp::Lte,
    ">=" => CmpOp::Gte,
};

init_stmt: Option<Assignment> = {
    <assign_expr> => Some(<>),
    empty => None,
};

incr_stmt: Option<Assignment> = {
    <assign_expr> => Some(<>),
    empty => None,
};

for_stmt: Stmt = {
    // TODO: What should `decl` return?
    start_for "(" <init: init_stmt> ";" <condition: cond> ";" <incr: incr_stmt> ")" decl <mut body: stmt_list> end_for => {
        // TODO: Add a comment for why we need to reverse statements.
        body.reverse();

        Stmt::For {
            init,
            condition,
            incr,
            body,
        }
    }
};

start_for: () = {
    FOR => {
        SymbolTable::add_anonymous_scope();
    },
};

end_for: () = {
    ROF => {
        SymbolTable::end_curr_scope();
    },
};